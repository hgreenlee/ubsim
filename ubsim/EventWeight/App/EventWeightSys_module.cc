////////////////////////////////////////////////////////////////////////
// Class:       EventWeight
// Module Type: producer
// File:        EventWeight_module.cc
//
// Generated at Fri Mar 20 09:36:11 2015 by Zarko Pavlovic using artmod
// from cetpkgsupport v1_08_04.
//
// Ported from uboonecode to larsim on Feb 14 2018 by Marco Del Tutto
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "cetlib_except/exception.h"

#include <memory>
#include <iostream>
#include <iomanip>
#include <map>
#include <set>

#include "larsim/EventWeight/Base/Weight_t.h"
#include "larsim/EventWeight/Base/MCEventWeight.h"
#include "larsim/EventWeight/Base/WeightManager.h"
#include "larsim/EventWeight/Base/WeightCalcCreator.h"
#include "larsim/EventWeight/Base/WeightCalc.h"

#include "CLHEP/Random/RandGaussQ.h"

#include "nutools/EventGeneratorBase/GENIE/GENIE2ART.h"

#include "nusimdata/SimulationBase/MCFlux.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/GTruth.h"

#include "GENIE/Framework/Conventions/KineVar.h"
#include "GENIE/Framework/EventGen/EventRecord.h"
#include "GENIE/Framework/Interaction/Interaction.h"
#include "GENIE/Framework/Interaction/Kinematics.h"
#include "GENIE/Framework/Messenger/Messenger.h"
#include "GENIE/Framework/Utils/AppInit.h"

#include "GENIE/RwFramework/GSystSet.h"
#include "GENIE/RwFramework/GSyst.h"
#include "GENIE/RwFramework/GReWeight.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNCEL.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQE.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCRES.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCOH.h"
#include "GENIE/RwCalculators/GReWeightNonResonanceBkg.h"
#include "GENIE/RwCalculators/GReWeightFGM.h"
#include "GENIE/RwCalculators/GReWeightDISNuclMod.h"
#include "GENIE/RwCalculators/GReWeightResonanceDecay.h"
#include "GENIE/RwCalculators/GReWeightFZone.h"
#include "GENIE/RwCalculators/GReWeightINuke.h"
#include "GENIE/RwCalculators/GReWeightAGKY.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQEaxial.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQEvec.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNCRES.h"
#include "GENIE/RwCalculators/GReWeightNuXSecDIS.h"
#include "GENIE/RwCalculators/GReWeightINukeParams.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNC.h"
#include "GENIE/RwCalculators/GReWeightXSecEmpiricalMEC.h"

namespace evwgh {

  class EventWeightSys : public art::EDProducer {
  public:
    explicit EventWeightSys(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    EventWeightSys(EventWeightSys const &) = delete;
    EventWeightSys(EventWeightSys &&) = delete;
    EventWeightSys & operator = (EventWeightSys const &) = delete;
    EventWeightSys & operator = (EventWeightSys &&) = delete;

  private:
    // Required functions.
    void produce(art::Event & e) override;

    //Optional functions.
    void endJob() override;
    
    bool valid_knob_name( const std::string& knob_name, genie::rew::GSyst_t& knob );

    //WeightManager _wgt_manager;
    std::string fGenieModuleLabel;

    std::vector<std::string> knob_name;
    std::vector< genie::rew::GSyst_t > knobs_to_use;

    size_t num_knobs;
    size_t num_sigs;

    std::vector< std::vector<genie::rew::GReWeight > > reweightVector; // [#knob][0,+-1,+-2,+-3 sigmas][genie::rew::GReWeight]
    std::vector<double> reweightingSigmas; // [0,+-1,+-2,+-3 sigmas] for all knobs

    std::vector< std::vector< std::vector<double> > > weights; // [#neutrino][#knob][0,+-1,+-2,+-3 sigmas]
  };

  EventWeightSys::EventWeightSys(fhicl::ParameterSet const & p)
    : EDProducer{p}
    , fGenieModuleLabel{p.get<std::string>("genie_module_label", "generator")}
  {
//    //?????
//    auto const n_func = _wgt_manager.Configure(p, *this);
//    if ( n_func > 0 )
    genie::Messenger* messenger = genie::Messenger::Instance();
messenger->SetPriorityLevel( "ReW", log4cpp::Priority::DEBUG );
      //MF_LOG_INFO("GENIEWeightCalc") << "Configuring GENIE weight"
       // << " calculator " << this->GetName();

    produces<std::vector<MCEventWeight> >();
 
    //const fhicl::ParameterSet& pset = p.get<fhicl::ParameterSet>( GetName() );
    auto const pars = p.get< std::vector<std::string> >( "parameter_list" );
    auto const par_sigmas = p.get< std::vector<double> >( "parameter_sigma" );

    for ( const auto& this_knob_name : pars ) {
      genie::rew::GSyst_t temp_knob = genie::rew::GSyst::FromString( this_knob_name );
      //if ( !(temp_knob != kNullSystematic && temp_knob != kNTwkDials) ) {
      //   knobs_to_use.push_back( temp_knob );
      //}
      //std::cout<<"knob_name: "<< this_knob_name<<std::endl;
      knobs_to_use.push_back( temp_knob );
      knob_name.push_back(this_knob_name);
    }

    num_knobs = knobs_to_use.size();
    num_sigs = par_sigmas.size();
    reweightingSigmas = par_sigmas;
    
    for (size_t i = 0u; i < num_sigs; i++){
      //std::cout<<"reweightingSigmas["<<i<<"]: "<<reweightingSigmas[i]<<std::endl;
    }

    reweightVector.resize( num_knobs, std::vector<genie::rew::GReWeight > (num_sigs) );
    
    //// Set up the weight calculators for each universe
    //for (unsigned int i_k = 0; i_k < num_knobs; i_k++){
    //  for ( auto& rwght : reweightVector.at(i_k) ) {

    //    ///////!!!!!!!!!!!!!!
    //    this->SetupWeightCalculators( rwght);
    //  }
    //} 

////////////////////////////
//    if ( pars.size() != par_sigmas.size() ) {
//      throw cet::exception(__PRETTY_FUNCTION__) << GetName()
//        << "::Bad fcl configuration. parameter_list and parameter_sigma"
//        << " need to have same number of parameters.";
//    }
//////////////////////////
  }

  void EventWeightSys::produce(art::Event & e)
  {
    // Implementation of required member function here.
    auto mcwghvec = std::make_unique<std::vector<MCEventWeight>>();

    // Get the MC generator information out of the event
    // These are both handles to MC information.
    art::Handle< std::vector<simb::MCTruth> > mcTruthHandle;
    art::Handle< std::vector<simb::GTruth> > gTruthHandle;

    // Actually go and get the stuff
    e.getByLabel( fGenieModuleLabel, mcTruthHandle );
    e.getByLabel( fGenieModuleLabel, gTruthHandle );

    std::vector< art::Ptr<simb::MCTruth> > mclist;
    art::fill_ptr_vector( mclist, mcTruthHandle );

    std::vector< art::Ptr<simb::GTruth > > glist;
    art::fill_ptr_vector( glist, gTruthHandle );

    size_t num_neutrinos = mclist.size();
    num_knobs = knobs_to_use.size();

    weights.resize( num_neutrinos );
    std::cout<<"size of weight []: "<< weights.size()<<std::endl;

    //std::cout<<"number of knobs: "<< num_knobs<<std::endl;
    //std::cout<<"number of variations: "<< num_sigs<<std::endl;
    // Loop over different number of neutrinos
    for (unsigned int i_v = 0; i_v < num_neutrinos; i_v++ ) {
      //std::cout<<"neutrino: "<<i_v<<std::endl;

      // Convert the MCTruth and GTruth objects from the event
      // back into the original genie::EventRecord needed to
      // compute the weights (GHEP)
      //std::unique_ptr< genie::EventRecord >
      genie::EventRecord *genie_event = (genie::EventRecord*)( evgb::RetrieveGHEP(*mclist[i_v], *glist[i_v]) );

      std::cout<<"----------- neutrino: "<< i_v <<" ------------"<<std::endl;
      std::cout<<*genie_event<<std::endl;
      std::cout<<"--------------------------------------"<<std::endl;

      // Set the final lepton kinetic energy and scattering cosine
      // in the owned GENIE kinematics object. This is done during
      // event generation but is not reproduced by evgb::RetrieveGHEP().
      // Several new CCMEC weight calculators developed for MicroBooNE
      // expect the variables to be set in this way (so that differential
      // cross sections can be recomputed). Failing to set them results
      // in inf and NaN weights.  
      genie::Interaction* interaction = genie_event->Summary();
      genie::Kinematics* kine_ptr = interaction->KinePtr();

      // Final lepton mass
      double ml = interaction->FSPrimLepton()->Mass();
      // Final lepton 4-momentum
      const TLorentzVector& p4l = kine_ptr->FSLeptonP4();
      // Final lepton kinetic energy
      double Tl = p4l.E() - ml;
      // Final lepton scattering cosine
      double ctl = p4l.CosTheta();

      kine_ptr->SetKV( kKVTl, Tl );
      kine_ptr->SetKV( kKVctl, ctl );

      // All right, the event record is fully ready. Now ask the GReWeight
      // objects to compute the weights.
      weights[i_v].resize( num_knobs );

      std::cout<<"size of weights [] []: "<< weights[i_v].size()<<std::endl;
      for (unsigned int i_k = 0; i_k < num_knobs; i_k++ ) {
        //std::cout<<"# knob: "<< i_k<<std::endl;
        std::cout<<"name of the knob: "<<knob_name[i_k]<<std::endl;
        for(unsigned int i_sig = 0; i_sig < num_sigs; i_sig++ ){
          //std::cout<<"# sig: "<<i_sig<<std::endl;
          weights[i_v][i_k].resize( num_sigs );

          //std::cout<<"huh?"<<std::endl;
          genie::rew::GReWeight& rwght = reweightVector.at( i_k ).at( i_sig );
        rwght.Print();	  
	//std::cout<<"nani?"<<std::endl;
	//genie::rew::GReWeightNuXSecCCQE *test1 = new GReWeightNuXSecCCQE;
	//std::cout<<"hmm?"<<std::endl;
	//genie::rew::GReWeightNuXSecNCEL *test2 = new GReWeightNuXSecNCEL;
	//std::cout << "DOUBLE NANI?!?!111" << std::endl;
	// genie::rew::GReWeightNuXSecCCQE *xsec_ccqe = new GReWeightNuXSecCCQE;
	calc_ccqe->SetMode( 0 );
          //rwght.AdoptWghtCalc( "xsec_ncel",       test2      );
          rwght.AdoptWghtCalc( "xsec_ncel",       new GReWeightNuXSecNCEL      );
          //std::cout<<"1"<<std::endl;
          //rwght.AdoptWghtCalc( "xsec_ccqe",       test1      );
	  //          rwght.AdoptWghtCalc( "xsec_ccqe",       xsec_ccqe);
	  rwght.AdoptWghtCalc( "xsec_ccqe",       new GReWeightNuXSecCCQE      );
          //std::cout<<"2"<<std::endl;
          rwght.AdoptWghtCalc( "xsec_ccqe_axial", new GReWeightNuXSecCCQEaxial );
          //std::cout<<"3"<<std::endl;
          rwght.AdoptWghtCalc( "xsec_ccqe_vec",   new GReWeightNuXSecCCQEvec   );
          //std::cout<<"4"<<std::endl;
          rwght.AdoptWghtCalc( "xsec_ccres",      new GReWeightNuXSecCCRES     );
          //std::cout<<"5"<<std::endl;
          rwght.AdoptWghtCalc( "xsec_ncres",      new GReWeightNuXSecNCRES     );
          //std::cout<<"6"<<std::endl;
          rwght.AdoptWghtCalc( "xsec_nonresbkg",  new GReWeightNonResonanceBkg );
          //std::cout<<"7"<<std::endl;
          rwght.AdoptWghtCalc( "xsec_coh",        new GReWeightNuXSecCOH       );
          //std::cout<<"8"<<std::endl;
          rwght.AdoptWghtCalc( "xsec_dis",        new GReWeightNuXSecDIS       );
          //std::cout<<"9"<<std::endl;
          rwght.AdoptWghtCalc( "nuclear_qe",      new GReWeightFGM             );
          //std::cout<<"10"<<std::endl;
          rwght.AdoptWghtCalc( "hadro_res_decay", new GReWeightResonanceDecay  );
          //std::cout<<"11"<<std::endl;
          rwght.AdoptWghtCalc( "hadro_fzone",     new GReWeightFZone           );
          //std::cout<<"12"<<std::endl;
          rwght.AdoptWghtCalc( "hadro_intranuke", new GReWeightINuke           );
          //std::cout<<"13"<<std::endl;
          rwght.AdoptWghtCalc( "hadro_agky",      new GReWeightAGKY            );
          //std::cout<<"14"<<std::endl;
          rwght.AdoptWghtCalc( "xsec_nc",         new GReWeightNuXSecNC        );
          //std::cout<<"15"<<std::endl;
          rwght.AdoptWghtCalc( "res_dk",          new GReWeightResonanceDecay  );
          //std::cout<<"16"<<std::endl;
          rwght.AdoptWghtCalc( "xsec_empmec",     new GReWeightXSecEmpiricalMEC);
          //std::cout<<"17"<<std::endl;

          genie::rew::GReWeightI* calc = rwght.WghtCalc( knob_name[i_k] );
          std::cout<<"knob_name[i_k]: "<<knob_name[i_k]<<std::endl;
          if (calc != nullptr) std::cout<<"calc not nullptr"<<std::endl;
          if (calc == nullptr) std::cout<<"what are you doing calc" <<std::endl;

          auto* calc_ccqe = dynamic_cast< genie::rew::GReWeightNuXSecCCQE* >( calc );
          auto* calc_ccres = dynamic_cast< genie::rew::GReWeightNuXSecCCRES* >( calc );
          auto* calc_ncres = dynamic_cast< genie::rew::GReWeightNuXSecNCRES* >( calc );
          auto* calc_dis = dynamic_cast< genie::rew::GReWeightNuXSecDIS* >( calc );
          std::cout<<"exodus"<<std::endl;
          if ( calc_ccqe ){
             std::cout<<"Der Anfang ist das Ende"<<std::endl;
             calc_ccqe->SetMode( 0 );
          }   
          else if ( calc_ccres ) calc_ccres->SetMode( 0 );
          else if ( calc_ncres ) calc_ncres->SetMode( 0 );
          else if ( calc_dis ) calc_dis->SetMode( 1 );

          if (calc_ccqe != nullptr) {
             std::cout<<"calc_ccqe not nullptr"<<std::endl;
          } 
          else
          { std::cout<<"puuuuuuu calc_ccqe" <<std::endl;}

          if (calc_ccres != nullptr) {
             std::cout<<"calc_ccres not nullptr"<<std::endl;
          }
          else
          { std::cout<<"puuuuuuu calc_ccres" <<std::endl;}

          if (calc_ncres != nullptr) {
             std::cout<<"calc_ncres not nullptr"<<std::endl;
          }
          else
          { std::cout<<"puuuuuuu calc_ncres" <<std::endl;}

          if (calc_dis != nullptr) {
             std::cout<<"calc_dis not nullptr"<<std::endl;
          }
          else
          { std::cout<<"puuuuuuu calc_dis" <<std::endl;}
          //std::cout<<"aaaaaaa"<<std::endl;
          //genie::rew::GSystSet& syst = rwght.Systematics();

          //std::cout<<"bbbbbb"<<std::endl;
          genie::rew::GSyst_t knob = knobs_to_use.at( i_k );

          double twk_dial_value = reweightingSigmas.at( i_sig );
          rwght.Systematics().Set( knob, twk_dial_value );
 
          rwght.Reconfigure();

          //std::cout<<"weight weight: "<< rwght.CalcWeight( *genie_event )<<std::endl;
          //std::cout<<"kabooo------------"<<std::endl; 
          weights[i_v][i_k][i_sig] = rwght.CalcWeight( *genie_event );
          std::cout<<"neutrino #: "<< i_v <<", knob: "<< knob_name[i_k] << ", var: "<< twk_dial_value<<std::endl;
          std::cout<<"weight: "<< weights[i_v][i_k][i_sig]<<std::endl;

	  // Something like:
	  // rwght.Reset();}
      }

      // fill the producer
      MCEventWeight mcwgh;
      for (unsigned int i_k = 0; i_k < num_knobs; i_k++ ){
        if(weights.size() == 0){
          std::vector<double> empty;
          std::pair<std::string, std::vector <double> > p("empty",empty);
          mcwgh.fWeight.insert(p);
        }
        else{
          std::pair<std::string, std::vector<double> > p(knob_name[i_k], weights[i_v][i_k]);
          mcwgh.fWeight.insert(p);
        }
      }
      mcwghvec->push_back(mcwgh);
    }

    e.put(std::move(mcwghvec));
  }

  void EventWeightSys::endJob()
  {
    //// Get the map from sting to Weight_t from the manager
    //std::map<std::string, Weight_t*> weightCalcMap = _wgt_manager.GetWeightCalcMap();

    //std::stringstream job_summary;
    //job_summary  <<  std::setprecision(2);
    //for (int i=1; i <= 110 ;i++) job_summary << "=";
    //job_summary << std::endl;
    //job_summary << std::setw(20) << "WeightCalc"
    //            << std::setw(15) << "Type"
    //            << std::setw(15) << "#RW neutrinos"
    //            << std::setw(15) << "#Multisims"
    //            << std::setw(15) << "Min"
    //            << std::setw(15) << "Max"
    //            << std::setw(15) << "Avg"
    //            << std::endl;
    //for (int i=1; i <= 110; i++) job_summary << "=";
    //job_summary << std::endl;
    //for (auto it = weightCalcMap.begin(); it!=weightCalcMap.end(); it++) {
    //  job_summary << std::setw(20) << it->first
    //              << std::setw(15) << (it->second->fWeightCalcType)
    //              << std::setw(15) << (it->second->fNcalls)
    //              << std::setw(15) << (it->second->fNmultisims)
    //              << std::setw(15) << (it->second->fMinWeight)
    //              << std::setw(15) << (it->second->fMaxWeight)
    //              << std::setw(15) << (it->second->fAvgWeight)
    //              << std::endl;
    //}
    //for (int i=1; i<=110; i++) job_summary << "=";
    //job_summary << std::endl;
    //mf::LogInfo("") << job_summary.str();
  }

  //bool valid_knob_name( const std::string& knob_name, genie::rew::GSyst_t& knob ) {
  //  knob = genie::rew::GSyst::FromString( knob_name );
  //  if ( knob != kNullSystematic && knob != kNTwkDials ) {
  //    //if ( UNIMPLEMENTED_GENIE_KNOBS.count(knob) ) {
  //    MF_LOG_WARNING("GENIEWeightCalc") << "Ignoring unimplemented GENIE"
  //      << " knob " << knob_name;
  //    return false;
  //    //}
  //  }
  //  else {
  //    MF_LOG_WARNING("GENIEWeightCalc") << "Ignoring unrecognized GENIE"
  //      << " knob " << knob_name;
  //    return false;
  //  }
  //  return true;
  //}

} // namespace

DEFINE_ART_MODULE(evwgh::EventWeightSys)
