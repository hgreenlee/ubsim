////////////////////////////////////////////////////////////////////////
// Class:       EventWeight
// Module Type: producer
// File:        EventWeight_module.cc
//
// Generated at Fri Mar 20 09:36:11 2015 by Zarko Pavlovic using artmod
// from cetpkgsupport v1_08_04.
//
// Ported from uboonecode to larsim on Feb 14 2018 by Marco Del Tutto
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "cetlib_except/exception.h"

#include <memory>
#include <iostream>
#include <iomanip>
#include <map>
#include <set>

#include "larsim/EventWeight/Base/Weight_t.h"
#include "larsim/EventWeight/Base/MCEventWeight.h"
#include "larsim/EventWeight/Base/WeightManager.h"
#include "larsim/EventWeight/Base/WeightCalcCreator.h"
#include "larsim/EventWeight/Base/WeightCalc.h"

#include "CLHEP/Random/RandGaussQ.h"

#include "nutools/EventGeneratorBase/GENIE/GENIE2ART.h"

#include "nusimdata/SimulationBase/MCFlux.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/GTruth.h"

#include "GENIE/Framework/Conventions/KineVar.h"
#include "GENIE/Framework/EventGen/EventRecord.h"
#include "GENIE/Framework/Interaction/Interaction.h"
#include "GENIE/Framework/Interaction/Kinematics.h"
#include "GENIE/Framework/Messenger/Messenger.h"
#include "GENIE/Framework/Utils/AppInit.h"

#include "GENIE/RwFramework/GSystSet.h"
#include "GENIE/RwFramework/GSyst.h"
#include "GENIE/RwFramework/GReWeight.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNCEL.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQE.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCRES.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCOH.h"
#include "GENIE/RwCalculators/GReWeightNonResonanceBkg.h"
#include "GENIE/RwCalculators/GReWeightFGM.h"
#include "GENIE/RwCalculators/GReWeightDISNuclMod.h"
#include "GENIE/RwCalculators/GReWeightResonanceDecay.h"
#include "GENIE/RwCalculators/GReWeightFZone.h"
#include "GENIE/RwCalculators/GReWeightINuke.h"
#include "GENIE/RwCalculators/GReWeightAGKY.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQEaxial.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQEvec.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNCRES.h"
#include "GENIE/RwCalculators/GReWeightNuXSecDIS.h"
#include "GENIE/RwCalculators/GReWeightINukeParams.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNC.h"
#include "GENIE/RwCalculators/GReWeightXSecEmpiricalMEC.h"

namespace evwgh {

  class EventWeightSys : public art::EDProducer {
  public:
    explicit EventWeightSys(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    EventWeightSys(EventWeightSys const &) = delete;
    EventWeightSys(EventWeightSys &&) = delete;
    EventWeightSys & operator = (EventWeightSys const &) = delete;
    EventWeightSys & operator = (EventWeightSys &&) = delete;

  private:
    // Required functions.
    void produce(art::Event & e) override;

    //Optional functions.
    void endJob() override;
    
    bool valid_knob_name( const std::string& knob_name, genie::rew::GSyst_t& knob );

    WeightManager _wgt_manager;
    std::string fGenieModuleLabel;

    std::vector<std::string> knob_name;
    std::vector< genie::rew::GSyst_t > knobs_to_use;

    size_t num_knobs;
    size_t num_sigs;

    std::vector< std::vector<genie::rew::GReWeight > > reweightVector; // [#knob][0,+-1,+-2,+-3 sigmas][genie::rew::GReWeight]
    std::vector< std::vector<double> > reweightingSigmas; // [#knob][0,+-1,+-2,+-3 sigmas]

    std::vector< std::vector< std::vector<double> > > weights; // [#neutrino][#knob][0,+-1,+-2,+-3 sigmas]
  };

  EventWeightSys::EventWeightSys(fhicl::ParameterSet const & p)
    : EDProducer{p}
    , fGenieModuleLabel{p.get<std::string>("genie_module_label", "generator")}
  {
    //?????
    auto const n_func = _wgt_manager.Configure(p, *this);
    if ( n_func > 0 )
      produces<std::vector<MCEventWeight> >();
 
    const fhicl::ParameterSet& pset = p.get<fhicl::ParameterSet>( GetName() );
    auto const pars = pset.get< std::vector<std::string> >( "parameter_list" );
    auto const par_sigmas = pset.get< std::vector<double> >( "parameter_sigma" );

    genie::rew::GSyst_t temp_knob;
    for ( const auto& knob_name : pars ) {
      if ( valid_knob_name(knob_name, temp_knob) ) knobs_to_use.push_back( temp_knob );
    }

    num_sigs = par_sigmas.size();

////////////////////////////
    if ( pars.size() != par_sigmas.size() ) {
      throw cet::exception(__PRETTY_FUNCTION__) << GetName()
        << "::Bad fcl configuration. parameter_list and parameter_sigma"
        << " need to have same number of parameters.";
    }
//////////////////////////
  }

  void EventWeightSys::produce(art::Event & e)
  {
    // Implementation of required member function here.
    auto mcwghvec = std::make_unique<std::vector<MCEventWeight>>();

    // Get the MC generator information out of the event
    // These are both handles to MC information.
    art::Handle< std::vector<simb::MCTruth> > mcTruthHandle;
    art::Handle< std::vector<simb::GTruth> > gTruthHandle;

    // Actually go and get the stuff
    e.getByLabel( fGenieModuleLabel, mcTruthHandle );
    e.getByLabel( fGenieModuleLabel, gTruthHandle );

    std::vector< art::Ptr<simb::MCTruth> > mclist;
    art::fill_ptr_vector( mclist, mcTruthHandle );

    std::vector< art::Ptr<simb::GTruth > > glist;
    art::fill_ptr_vector( glist, gTruthHandle );

    size_t num_neutrinos = mclist.size();
    num_knobs = knobs_to_use.size();

    weights.resize( num_neutrinos );

    // Loop over different number of neutrinos
    for (unsigned int i_v = 0; i_v < num_neutrinos; i_v++ ) {

      // Convert the MCTruth and GTruth objects from the event
      // back into the original genie::EventRecord needed to
      // compute the weights (GHEP)
      std::unique_ptr< genie::EventRecord >
        genie_event( evgb::RetrieveGHEP(*mclist[i_v], *glist[i_v]) );

      // Set the final lepton kinetic energy and scattering cosine
      // in the owned GENIE kinematics object. This is done during
      // event generation but is not reproduced by evgb::RetrieveGHEP().
      // Several new CCMEC weight calculators developed for MicroBooNE
      // expect the variables to be set in this way (so that differential
      // cross sections can be recomputed). Failing to set them results
      // in inf and NaN weights.  
      genie::Interaction* interaction = genie_event->Summary();
      genie::Kinematics* kine_ptr = interaction->KinePtr();

      // Final lepton mass
      double ml = interaction->FSPrimLepton()->Mass();
      // Final lepton 4-momentum
      const TLorentzVector& p4l = kine_ptr->FSLeptonP4();
      // Final lepton kinetic energy
      double Tl = p4l.E() - ml;
      // Final lepton scattering cosine
      double ctl = p4l.CosTheta();

      kine_ptr->SetKV( kKVTl, Tl );
      kine_ptr->SetKV( kKVctl, ctl );

      // All right, the event record is fully ready. Now ask the GReWeight
      // objects to compute the weights.
      weights[i_v].resize( num_knobs );

      for (unsigned int i_k = 0; i_k < num_knobs; i_k++ ) {
        std::cout<<"name of the knob: "<<knob_name[i_k]<<std::endl;
        for(unsigned int i_sig = 0; i_sig < num_sigs; i_sig++ ){

          auto& rwght = reweightVector.at( i_k ).at( i_sig );
          genie::rew::GSystSet& syst = rwght.Systematics();

          genie::rew::GSyst_t knob = knobs_to_use.at( i_k );

          double twk_dial_value = reweightingSigmas.at( i_k ).at( i_sig );
          syst.Set( knob, twk_dial_value );

          weights[i_v][i_k][i_sig] = rwght.CalcWeight( *genie_event );
          std::cout<<"weight: "<< weights[i_v][i_k][i_sig]<<std::endl;
        }
      }

      // fill the producer
      MCEventWeight mcwgh;
      for (unsigned int i_k = 0; i_k < num_knobs; i_k++ ){
        if(weights.size() == 0){
          std::vector<double> empty;
          std::pair<std::string, std::vector <double> > p("empty",empty);
          mcwgh.fWeight.insert(p);
        }
        else{
          std::pair<std::string, std::vector<double> > p(knob_name[i_k], weights[i_v][i_k]);
          mcwgh.fWeight.insert(p);
        }
      }
      mcwghvec->push_back(mcwgh);
    }

    e.put(std::move(mcwghvec));
  }

  void EventWeightSys::endJob()
  {
    //// Get the map from sting to Weight_t from the manager
    //std::map<std::string, Weight_t*> weightCalcMap = _wgt_manager.GetWeightCalcMap();

    //std::stringstream job_summary;
    //job_summary  <<  std::setprecision(2);
    //for (int i=1; i <= 110 ;i++) job_summary << "=";
    //job_summary << std::endl;
    //job_summary << std::setw(20) << "WeightCalc"
    //            << std::setw(15) << "Type"
    //            << std::setw(15) << "#RW neutrinos"
    //            << std::setw(15) << "#Multisims"
    //            << std::setw(15) << "Min"
    //            << std::setw(15) << "Max"
    //            << std::setw(15) << "Avg"
    //            << std::endl;
    //for (int i=1; i <= 110; i++) job_summary << "=";
    //job_summary << std::endl;
    //for (auto it = weightCalcMap.begin(); it!=weightCalcMap.end(); it++) {
    //  job_summary << std::setw(20) << it->first
    //              << std::setw(15) << (it->second->fWeightCalcType)
    //              << std::setw(15) << (it->second->fNcalls)
    //              << std::setw(15) << (it->second->fNmultisims)
    //              << std::setw(15) << (it->second->fMinWeight)
    //              << std::setw(15) << (it->second->fMaxWeight)
    //              << std::setw(15) << (it->second->fAvgWeight)
    //              << std::endl;
    //}
    //for (int i=1; i<=110; i++) job_summary << "=";
    //job_summary << std::endl;
    //mf::LogInfo("") << job_summary.str();
  }

  bool valid_knob_name( const std::string& knob_name, genie::rew::GSyst_t& knob ) {
    knob = genie::rew::GSyst::FromString( knob_name );
    if ( knob != kNullSystematic && knob != kNTwkDials ) {
      if ( UNIMPLEMENTED_GENIE_KNOBS.count(knob) ) {
        MF_LOG_WARNING("GENIEWeightCalc") << "Ignoring unimplemented GENIE"
          << " knob " << knob_name;
        return false;
      }
    }
    else {
      MF_LOG_WARNING("GENIEWeightCalc") << "Ignoring unrecognized GENIE"
        << " knob " << knob_name;
      return false;
    }
    return true;
  }

} // namespace

DEFINE_ART_MODULE(EventWeightSys)
