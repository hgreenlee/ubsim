////////////////////////////////////////////////////////////////////////
// Class:       EventWeight
// Module Type: producer
// File:        EventWeight_module.cc
//
// Generated at Fri Mar 20 09:36:11 2015 by Zarko Pavlovic using artmod
// from cetpkgsupport v1_08_04.
//
// Ported from uboonecode to larsim on Feb 14 2018 by Marco Del Tutto
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "cetlib_except/exception.h"

#include <memory>
#include <iostream>
#include <iomanip>
#include <map>
#include <set>

#include "larsim/EventWeight/Base/Weight_t.h"
#include "larsim/EventWeight/Base/MCEventWeight.h"
#include "larsim/EventWeight/Base/WeightManager.h"
#include "larsim/EventWeight/Base/WeightCalcCreator.h"
#include "larsim/EventWeight/Base/WeightCalc.h"

#include "CLHEP/Random/RandGaussQ.h"

#include "nutools/EventGeneratorBase/GENIE/GENIE2ART.h"

#include "nusimdata/SimulationBase/MCFlux.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/GTruth.h"

#include "GENIE/Framework/Conventions/KineVar.h"
#include "GENIE/Framework/EventGen/EventRecord.h"
#include "GENIE/Framework/Interaction/Interaction.h"
#include "GENIE/Framework/Interaction/Kinematics.h"
#include "GENIE/Framework/Messenger/Messenger.h"
#include "GENIE/Framework/Utils/AppInit.h"

#include "GENIE/RwFramework/GSystSet.h"
#include "GENIE/RwFramework/GSyst.h"
#include "GENIE/RwFramework/GReWeight.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNCEL.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQE.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCRES.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCOH.h"
#include "GENIE/RwCalculators/GReWeightNonResonanceBkg.h"
#include "GENIE/RwCalculators/GReWeightFGM.h"
#include "GENIE/RwCalculators/GReWeightDISNuclMod.h"
#include "GENIE/RwCalculators/GReWeightResonanceDecay.h"
#include "GENIE/RwCalculators/GReWeightFZone.h"
#include "GENIE/RwCalculators/GReWeightINuke.h"
#include "GENIE/RwCalculators/GReWeightAGKY.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQEaxial.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQEvec.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNCRES.h"
#include "GENIE/RwCalculators/GReWeightNuXSecDIS.h"
#include "GENIE/RwCalculators/GReWeightINukeParams.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNC.h"
#include "GENIE/RwCalculators/GReWeightXSecEmpiricalMEC.h"

namespace evwghYC {

  class EventWeightSysYC : public art::EDProducer {
  public:
    explicit EventWeightSysYC(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    EventWeightSysYC(EventWeightSysYC const &) = delete;
    EventWeightSysYC(EventWeightSysYC &&) = delete;
    EventWeightSysYC & operator = (EventWeightSysYC const &) = delete;
    EventWeightSysYC & operator = (EventWeightSysYC &&) = delete;

  private:
    // Required functions.
    void produce(art::Event & e) override;

    //Optional functions.
    void endJob() override;
    
    bool valid_knob_name( const std::string& knob_name, genie::rew::GSyst_t& knob );

    //WeightManager _wgt_manager;
    std::string fGenieModuleLabel;

    std::vector<std::string> knob_name;
    std::vector< genie::rew::GSyst_t > knobs_to_use;

    size_t num_knobs;
    size_t num_sigs;

    std::vector< genie::rew::GReWeight > reweightVector; // [#knob][genie::rew::GReWeight]
    std::vector<double> reweightingSigmas; // [0,+-1,+-2,+-3 sigmas] for all knobs

    std::vector< std::vector< std::vector<double> > > weights; // [#neutrino][#knob][0,+-1,+-2,+-3 sigmas]
  };

  EventWeightSysYC::EventWeightSysYC(fhicl::ParameterSet const & p)
    : EDProducer{p}
    , fGenieModuleLabel{p.get<std::string>("genie_module_label", "generator")}
  {
//    //?????
//    auto const n_func = _wgt_manager.Configure(p, *this);
//    if ( n_func > 0 )
    genie::Messenger* messenger = genie::Messenger::Instance();
messenger->SetPriorityLevel( "ReW", log4cpp::Priority::DEBUG );
      //MF_LOG_INFO("GENIEWeightCalc") << "Configuring GENIE weight"
       // << " calculator " << this->GetName();

    produces<std::vector<evwgh::MCEventWeight> >();
 
    //const fhicl::ParameterSet& pset = p.get<fhicl::ParameterSet>( GetName() );
    auto const pars = p.get< std::vector<std::string> >( "parameter_list" );
    auto const par_sigmas = p.get< std::vector<double> >( "parameter_sigma" );

    for ( const auto& this_knob_name : pars ) {
      genie::rew::GSyst_t temp_knob = genie::rew::GSyst::FromString( this_knob_name );
      knobs_to_use.push_back( temp_knob );
      knob_name.push_back(this_knob_name);
    }

    num_knobs = knobs_to_use.size();
    num_sigs = par_sigmas.size();
    reweightingSigmas = par_sigmas;
    
    std::vector<std::string> v_calc_name = {"xsec_ncel",  "xsec_ccqe", "xsec_ccqe_axial", "xsec_ccqe_vec", "xsec_ccres", "xsec_ncres", "xsec_nonresbkg", "xsec_coh", "xsec_dis", "nuclear_qe", "hadro_res_decay", "hadro_fzone", "hadro_intranuke", "hadro_intranuke", "hadro_agky", "xsec_nc", "res_dk", "xsec_empmec"};

    reweightVector.resize( num_knobs );
    for ( auto& rwght : reweightVector ) {   

      //rwght.Print();

      rwght.AdoptWghtCalc( "xsec_ncel",       new GReWeightNuXSecNCEL      );
      rwght.AdoptWghtCalc( "xsec_ccqe",       new GReWeightNuXSecCCQE      );
      rwght.AdoptWghtCalc( "xsec_ccqe_axial", new GReWeightNuXSecCCQEaxial );
      rwght.AdoptWghtCalc( "xsec_ccqe_vec",   new GReWeightNuXSecCCQEvec   );
      rwght.AdoptWghtCalc( "xsec_ccres",      new GReWeightNuXSecCCRES     );
      rwght.AdoptWghtCalc( "xsec_ncres",      new GReWeightNuXSecNCRES     );
      rwght.AdoptWghtCalc( "xsec_nonresbkg",  new GReWeightNonResonanceBkg );
      rwght.AdoptWghtCalc( "xsec_coh",        new GReWeightNuXSecCOH       );
      rwght.AdoptWghtCalc( "xsec_dis",        new GReWeightNuXSecDIS       );
      rwght.AdoptWghtCalc( "nuclear_qe",      new GReWeightFGM             );
      rwght.AdoptWghtCalc( "hadro_res_decay", new GReWeightResonanceDecay  );
      rwght.AdoptWghtCalc( "hadro_fzone",     new GReWeightFZone           );
      rwght.AdoptWghtCalc( "hadro_intranuke", new GReWeightINuke           );
      rwght.AdoptWghtCalc( "hadro_agky",      new GReWeightAGKY            );
      rwght.AdoptWghtCalc( "xsec_nc",         new GReWeightNuXSecNC        );
      rwght.AdoptWghtCalc( "res_dk",          new GReWeightResonanceDecay  );
      rwght.AdoptWghtCalc( "xsec_empmec",     new GReWeightXSecEmpiricalMEC);


      for (auto& calc_name : v_calc_name) { 
        genie::rew::GReWeightI* calc = rwght.WghtCalc( calc_name );

        auto* calc_ccqe = dynamic_cast< genie::rew::GReWeightNuXSecCCQE* >( calc );
        auto* calc_ccres = dynamic_cast< genie::rew::GReWeightNuXSecCCRES* >( calc );
        auto* calc_ncres = dynamic_cast< genie::rew::GReWeightNuXSecNCRES* >( calc );
        auto* calc_dis = dynamic_cast< genie::rew::GReWeightNuXSecDIS* >( calc );
        if ( calc_ccqe ) {calc_ccqe->SetMode( 0 );}
        else if ( calc_ccres ) calc_ccres->SetMode( 0 );
        else if ( calc_ncres ) calc_ncres->SetMode( 0 );
        else if ( calc_dis ) calc_dis->SetMode( 1 ); 
      }
    }
  }

  void EventWeightSysYC::produce(art::Event & e)
  {
    // Implementation of required member function here.
    auto mcwghvec = std::make_unique<std::vector<evwgh::MCEventWeight>>();

    // Get the MC generator information out of the event
    // These are both handles to MC information.
    art::Handle< std::vector<simb::MCTruth> > mcTruthHandle;
    art::Handle< std::vector<simb::GTruth> > gTruthHandle;

    // Actually go and get the stuff
    e.getByLabel( fGenieModuleLabel, mcTruthHandle );
    e.getByLabel( fGenieModuleLabel, gTruthHandle );

    std::vector< art::Ptr<simb::MCTruth> > mclist;
    art::fill_ptr_vector( mclist, mcTruthHandle );

    std::vector< art::Ptr<simb::GTruth > > glist;
    art::fill_ptr_vector( glist, gTruthHandle );

    size_t num_neutrinos = mclist.size();
    num_knobs = knobs_to_use.size();

    weights.resize( num_neutrinos );
    // Loop over different number of neutrinos
    for (unsigned int i_v = 0; i_v < num_neutrinos; i_v++ ) {

      // Convert the MCTruth and GTruth objects from the event
      // back into the original genie::EventRecord needed to
      // compute the weights (GHEP)
      //std::unique_ptr< genie::EventRecord >
      genie::EventRecord *genie_event = (genie::EventRecord*)( evgb::RetrieveGHEP(*mclist[i_v], *glist[i_v]) );

      //std::cout<<*genie_event<<std::endl;

      // Set the final lepton kinetic energy and scattering cosine
      // in the owned GENIE kinematics object. This is done during
      // event generation but is not reproduced by evgb::RetrieveGHEP().
      // Several new CCMEC weight calculators developed for MicroBooNE
      // expect the variables to be set in this way (so that differential
      // cross sections can be recomputed). Failing to set them results
      // in inf and NaN weights.  
      genie::Interaction* interaction = genie_event->Summary();
      genie::Kinematics* kine_ptr = interaction->KinePtr();

      // Final lepton mass
      double ml = interaction->FSPrimLepton()->Mass();
      // Final lepton 4-momentum
      const TLorentzVector& p4l = kine_ptr->FSLeptonP4();
      // Final lepton kinetic energy
      double Tl = p4l.E() - ml;
      // Final lepton scattering cosine
      double ctl = p4l.CosTheta();

      kine_ptr->SetKV( kKVTl, Tl );
      kine_ptr->SetKV( kKVctl, ctl );

      // All right, the event record is fully ready. Now ask the GReWeight
      // objects to compute the weights.
      weights[i_v].resize( num_knobs );

      for (unsigned int i_k = 0; i_k < num_knobs; i_k++ ) {
        auto& rw = reweightVector.at( i_k );

        for(unsigned int i_sig = 0; i_sig < num_sigs; i_sig++ ){
          weights[i_v][i_k].resize( num_sigs );
          genie::rew::GSyst_t knob = knobs_to_use.at( i_k );

          double twk_dial_value = reweightingSigmas.at( i_sig );
          rw.Systematics().Set( knob, twk_dial_value );

          rw.Reconfigure();

          weights[i_v][i_k][i_sig] = rw.CalcWeight( *genie_event );
          //std::cout<<"weight: "<< weights[i_v][i_k][i_sig]<<std::endl;

	}
      }

      // fill the producer
      evwgh::MCEventWeight mcwgh;
      for (unsigned int i_k = 0; i_k < num_knobs; i_k++ ){
        if(weights.size() == 0){
          std::vector<double> empty;
          std::pair<std::string, std::vector <double> > p("empty",empty);
          mcwgh.fWeight.insert(p);
        }
        else{
          std::pair<std::string, std::vector<double> > p(knob_name[i_k], weights[i_v][i_k]);
          mcwgh.fWeight.insert(p);
        }
      } // knobs
      mcwghvec->push_back(mcwgh);
    } // neutrino

    e.put(std::move(mcwghvec));
  }

  void EventWeightSysYC::endJob()
  {
  }

} // namespace

DEFINE_ART_MODULE(evwghYC::EventWeightSysYC)
