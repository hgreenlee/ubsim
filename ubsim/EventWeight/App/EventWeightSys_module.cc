////////////////////////////////////////////////////////////////////////
// Class:       EventWeight
// Module Type: producer
// File:        EventWeight_module.cc
//
// Generated at Fri Mar 20 09:36:11 2015 by Zarko Pavlovic using artmod
// from cetpkgsupport v1_08_04.
//
// Ported from uboonecode to larsim on Feb 14 2018 by Marco Del Tutto
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "cetlib_except/exception.h"

#include <memory>
#include <iostream>
#include <iomanip>
#include <map>
#include <set>

#include "larsim/EventWeight/Base/Weight_t.h"
#include "larsim/EventWeight/Base/MCEventWeight.h"
#include "larsim/EventWeight/Base/WeightManager.h"
#include "larsim/EventWeight/Base/WeightCalcCreator.h"
#include "larsim/EventWeight/Base/WeightCalc.h"

#include "CLHEP/Random/RandGaussQ.h"

#include "nutools/EventGeneratorBase/GENIE/GENIE2ART.h"

#include "nusimdata/SimulationBase/MCFlux.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/GTruth.h"

#include "GENIE/Framework/Conventions/KineVar.h"
#include "GENIE/Framework/EventGen/EventRecord.h"
#include "GENIE/Framework/Interaction/Interaction.h"
#include "GENIE/Framework/Interaction/Kinematics.h"
#include "GENIE/Framework/Messenger/Messenger.h"
#include "GENIE/Framework/Utils/AppInit.h"

#include "GENIE/RwFramework/GSystSet.h"
#include "GENIE/RwFramework/GSyst.h"
#include "GENIE/RwFramework/GReWeight.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNCEL.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQE.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCRES.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCOH.h"
#include "GENIE/RwCalculators/GReWeightNonResonanceBkg.h"
#include "GENIE/RwCalculators/GReWeightFGM.h"
#include "GENIE/RwCalculators/GReWeightDISNuclMod.h"
#include "GENIE/RwCalculators/GReWeightResonanceDecay.h"
#include "GENIE/RwCalculators/GReWeightFZone.h"
#include "GENIE/RwCalculators/GReWeightINuke.h"
#include "GENIE/RwCalculators/GReWeightAGKY.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQEaxial.h"
#include "GENIE/RwCalculators/GReWeightNuXSecCCQEvec.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNCRES.h"
#include "GENIE/RwCalculators/GReWeightNuXSecDIS.h"
#include "GENIE/RwCalculators/GReWeightINukeParams.h"
#include "GENIE/RwCalculators/GReWeightNuXSecNC.h"
#include "GENIE/RwCalculators/GReWeightXSecEmpiricalMEC.h"

#ifdef GENIE_UB_PATCH
  // New weight calculator in GENIE v3.0.4 MicroBooNE patch 01
  #include "GENIE/RwCalculators/GReWeightXSecMEC.h"
  // New weight calculators in GENIE v3.0.4 MicroBooNE patch 02
  #include "GENIE/RwCalculators/GReWeightDeltaradAngle.h"
  #include "GENIE/RwCalculators/GReWeightNuXSecCOHuB.h"
  #include "GENIE/RwCalculators/GReWeightRESBugFix.h"
#endif

namespace evwghYC {

  class EventWeightSysYC : public art::EDProducer {
  public:
    explicit EventWeightSysYC(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    EventWeightSysYC(EventWeightSysYC const &) = delete;
    EventWeightSysYC(EventWeightSysYC &&) = delete;
    EventWeightSysYC & operator = (EventWeightSysYC const &) = delete;
    EventWeightSysYC & operator = (EventWeightSysYC &&) = delete;

  private:
    // Required functions.
    void produce(art::Event & e) override;

    //Optional functions.
    void beginJob() override;
    void endJob() override;

    //WeightManager _wgt_manager;
    std::string fGenieModuleLabel;

    std::vector<std::string> knob_name;
    std::vector< genie::rew::GSyst_t > knobs_to_use;

    std::vector<std::string> tuned_knob_name;
    std::vector< genie::rew::GSyst_t > tuned_knobs_to_use;

    size_t num_knobs;
    size_t num_sigs;

    size_t tuned_num_knobs;
    size_t tuned_num_sigs;

    std::vector<double> reweightingSigmas; // [0,+-1,+-2,+-3 sigmas] for all knobs
    double cv = 0.;

    std::vector<double> tuned_reweightingSigmas; // [0,+-1,+-2,+-3 sigmas] for all knobs
    double tuned_cv = 0.;
   
    genie::rew::GReWeight rwght;

    std::vector< std::vector< std::vector<double> > > weights; // [#neutrino][#knob][0,+-1,+-2,+-3 sigmas]
  };

  EventWeightSysYC::EventWeightSysYC(fhicl::ParameterSet const & p)
    : EDProducer{p}
    , fGenieModuleLabel{p.get<std::string>("genie_module_label", "generator")}
  {
//    //?????
//    auto const n_func = _wgt_manager.Configure(p, *this);
//    if ( n_func > 0 )
   genie::Messenger* messenger = genie::Messenger::Instance();
   messenger->SetPriorityLevel( "ReW", log4cpp::Priority::DEBUG );
      //MF_LOG_INFO("GENIEWeightCalc") << "Configuring GENIE weight"
       // << " calculator " << this->GetName();

    // Tell GENIE about the event generator list and tune
    evgb::SetEventGeneratorListAndTune( "Default", "G18_10a_02_11a" );
 
    produces<std::vector<evwgh::MCEventWeight> >();
 
    auto const pars = p.get< std::vector<std::string> >( "parameter_list" );
    auto const par_sigmas = p.get< std::vector<double> >( "parameter_sigma" );

    for ( const auto& this_knob_name : pars ) {
      genie::rew::GSyst_t temp_knob = genie::rew::GSyst::FromString( this_knob_name );
      knobs_to_use.push_back( temp_knob );
      knob_name.push_back(this_knob_name);
    }

    num_knobs = knobs_to_use.size();
    num_sigs = par_sigmas.size();
    reweightingSigmas = par_sigmas;
    cv = reweightingSigmas.at(0); 

    auto const tuned_pars = p.get< std::vector<std::string> >( "tuned_parameter_list" );
    auto const tuned_par_sigmas = p.get< std::vector<double> >( "tuned_parameter_sigma" );

    for ( const auto& this_knob_name : tuned_pars ) {
      genie::rew::GSyst_t temp_knob = genie::rew::GSyst::FromString( this_knob_name );
      tuned_knobs_to_use.push_back( temp_knob );
      tuned_knob_name.push_back(this_knob_name);
    }
   
    tuned_num_knobs = tuned_knobs_to_use.size();
    tuned_num_sigs = tuned_par_sigmas.size();
    tuned_reweightingSigmas = tuned_par_sigmas;
    tuned_cv = tuned_reweightingSigmas.at(0);

    std::cout<<"tuned_cv: "<< tuned_cv<<std::endl;


    //rwght.Print();
    genie::rew::GReWeightNuXSecCCQE* calc_ccqe = new GReWeightNuXSecCCQE;
    genie::rew::GReWeightNuXSecCCRES* calc_ccres = new GReWeightNuXSecCCRES;
    genie::rew::GReWeightNuXSecNCRES* calc_ncres = new GReWeightNuXSecNCRES;
    genie::rew::GReWeightNuXSecDIS* calc_dis = new GReWeightNuXSecDIS;


    calc_ccqe->SetMode( 0 );
    calc_ccres->SetMode( 0 );
    calc_ncres->SetMode( 0 );
    calc_dis->SetMode( 0 );

    rwght.AdoptWghtCalc( "xsec_ncel",       new GReWeightNuXSecNCEL      );
    rwght.AdoptWghtCalc( "xsec_ccqe",       calc_ccqe);
    rwght.AdoptWghtCalc( "xsec_ccqe_axial", new GReWeightNuXSecCCQEaxial );
    rwght.AdoptWghtCalc( "xsec_ccqe_vec",   new GReWeightNuXSecCCQEvec   );
    rwght.AdoptWghtCalc( "xsec_ccres",      new GReWeightNuXSecCCRES     );
    rwght.AdoptWghtCalc( "xsec_ncres",      new GReWeightNuXSecNCRES     );
    rwght.AdoptWghtCalc( "xsec_nonresbkg",  new GReWeightNonResonanceBkg );
    rwght.AdoptWghtCalc( "xsec_coh",        new GReWeightNuXSecCOH       );
    rwght.AdoptWghtCalc( "xsec_dis",        new GReWeightNuXSecDIS       );
    rwght.AdoptWghtCalc( "nuclear_qe",      new GReWeightFGM             );
    rwght.AdoptWghtCalc( "hadro_res_decay", new GReWeightResonanceDecay  );
    rwght.AdoptWghtCalc( "hadro_fzone",     new GReWeightFZone           );
    rwght.AdoptWghtCalc( "hadro_intranuke", new GReWeightINuke           );
    rwght.AdoptWghtCalc( "hadro_agky",      new GReWeightAGKY            );
    rwght.AdoptWghtCalc( "xsec_nc",         new GReWeightNuXSecNC        );
    rwght.AdoptWghtCalc( "res_dk",          new GReWeightResonanceDecay  );
    rwght.AdoptWghtCalc( "xsec_empmec",     new GReWeightXSecEmpiricalMEC);

    #ifdef GENIE_UB_PATCH
      // New weight calculator in GENIE v3.0.4 MicroBooNE patch 01
      rwght.AdoptWghtCalc( "xsec_mec",        new GReWeightXSecMEC );
      // New weight calculators in GENIE v3.0.4 MicroBooNE patch 02
      rwght.AdoptWghtCalc( "deltarad_angle",  new GReWeightDeltaradAngle );
      rwght.AdoptWghtCalc( "xsec_coh_ub",  new GReWeightNuXSecCOHuB );
      rwght.AdoptWghtCalc( "res_bug_fix",  new GReWeightRESBugFix );
    #endif

    // assuming MaCCQE is the only one that needs to be engineered
    genie::rew::GSyst_t knob_maccqe = tuned_knobs_to_use.at(0);
    rwght.Systematics().Set( knob_maccqe, tuned_cv );
    rwght.Reconfigure();
      //for (auto& calc_name : v_calc_name) { 
      //  genie::rew::GReWeightI* calc = rwght.WghtCalc( calc_name );

      //  //auto* calc_ccqe = dynamic_cast< genie::rew::GReWeightNuXSecCCQE* >( calc );
      //  auto* calc_ccres = dynamic_cast< genie::rew::GReWeightNuXSecCCRES* >( calc );
      //  auto* calc_ncres = dynamic_cast< genie::rew::GReWeightNuXSecNCRES* >( calc );
      //  auto* calc_dis = dynamic_cast< genie::rew::GReWeightNuXSecDIS* >( calc );
      //  //if ( calc_ccqe ) {calc_ccqe->SetMode( 0 );}
      //  else if ( calc_ccres ) calc_ccres->SetMode( 0 );
      //  else if ( calc_ncres ) calc_ncres->SetMode( 0 );
      //  else if ( calc_dis ) calc_dis->SetMode( 1 ); 
      //}
    //}
  }

  void EventWeightSysYC::produce(art::Event & e)
  {

    // Implementation of required member function here.
    auto mcwghvec = std::make_unique<std::vector<evwgh::MCEventWeight>>();

    // Get the MC generator information out of the event
    // These are both handles to MC information.
    art::Handle< std::vector<simb::MCTruth> > mcTruthHandle;
    art::Handle< std::vector<simb::GTruth> > gTruthHandle;

    // Actually go and get the stuff
    e.getByLabel( fGenieModuleLabel, mcTruthHandle );
    e.getByLabel( fGenieModuleLabel, gTruthHandle );

    std::vector< art::Ptr<simb::MCTruth> > mclist;
    art::fill_ptr_vector( mclist, mcTruthHandle );

    std::vector< art::Ptr<simb::GTruth > > glist;
    art::fill_ptr_vector( glist, gTruthHandle );

    size_t num_neutrinos = mclist.size();
    num_knobs = knobs_to_use.size();

    weights.resize( num_neutrinos );
    // Loop over different number of neutrinos
    for (unsigned int i_v = 0; i_v < num_neutrinos; i_v++ ) {

      // what to produce
      evwgh::MCEventWeight mcwgh;
      
      // Convert the MCTruth and GTruth objects from the event
      // back into the original genie::EventRecord needed to
      // compute the weights (GHEP)
      //std::unique_ptr< genie::EventRecord >
      genie::EventRecord *genie_event = (genie::EventRecord*)( evgb::RetrieveGHEP(*mclist[i_v], *glist[i_v]) );


      // Set the final lepton kinetic energy and scattering cosine
      // in the owned GENIE kinematics object. This is done during
      // event generation but is not reproduced by evgb::RetrieveGHEP().
      // Several new CCMEC weight calculators developed for MicroBooNE
      // expect the variables to be set in this way (so that differential
      // cross sections can be recomputed). Failing to set them results
      // in inf and NaN weights.  
      genie::Interaction* interaction = genie_event->Summary();
      genie::Kinematics* kine_ptr = interaction->KinePtr();

      // Final lepton mass
      double ml = interaction->FSPrimLepton()->Mass();
      // Final lepton 4-momentum
      const TLorentzVector& p4l = kine_ptr->FSLeptonP4();
      // Final lepton kinetic energy
      double Tl = p4l.E() - ml;
      // Final lepton scattering cosine
      double ctl = p4l.CosTheta();

      kine_ptr->SetKV( kKVTl, Tl );
      kine_ptr->SetKV( kKVctl, ctl );

      // All right, the event record is fully ready. Now ask the GReWeight
      // objects to compute the weights.
      weights[i_v].resize( num_knobs + tuned_num_knobs );

      for (unsigned int i_k = 0; i_k < num_knobs; i_k++ ) {
        //auto& rw = reweightVector.at( i_k );

        genie::rew::GSyst_t knob = knobs_to_use.at( i_k );

        for(unsigned int i_sig = 0; i_sig < num_sigs; i_sig++ ){
          weights[i_v][i_k].resize( num_sigs );

          double twk_dial_value = reweightingSigmas.at( i_sig );
          rwght.Systematics().Set( knob, twk_dial_value );

          rwght.Reconfigure();

          weights[i_v][i_k][i_sig] = rwght.CalcWeight( *genie_event );
          std::cout<<"--neutrino: "<< i_v <<", knob: "<<knob_name[i_k]<<", var: "<<twk_dial_value<<std::endl;
          std::cout<<"weight: "<< weights[i_v][i_k][i_sig]<<std::endl;
	}
        
        rwght.Systematics().Set( knob, cv );
        rwght.Reconfigure();

        //fill the producer
        std::pair<std::string, std::vector<double> > p(knob_name[i_k], weights[i_v][i_k]);
        mcwgh.fWeight.insert(p);

      }

      // vulnerable
      // MaCCQE
      for (unsigned int i_k = 0; i_k < tuned_num_knobs; i_k++ ) {

        unsigned int w_i_k = i_k + num_knobs;

        genie::rew::GSyst_t knob = tuned_knobs_to_use.at( i_k );
        for(unsigned int i_sig = 0; i_sig < tuned_num_sigs; i_sig++ ){
          weights[i_v][w_i_k].resize( tuned_num_sigs );

          double twk_dial_value = tuned_reweightingSigmas.at( i_sig );
          rwght.Systematics().Set( knob, twk_dial_value );

          rwght.Reconfigure();

          weights[i_v][w_i_k][i_sig] = rwght.CalcWeight( *genie_event );
          std::cout<<"--neutrino: "<< i_v <<", knob: "<<tuned_knob_name[i_k]<<", var: "<<twk_dial_value<<std::endl;
          std::cout<<"weight: "<< weights[i_v][w_i_k][i_sig]<<std::endl;
          }

        rwght.Systematics().Set( knob, tuned_cv );
        rwght.Reconfigure();
        std::pair<std::string, std::vector<double> > p(tuned_knob_name[i_k], weights[i_v][w_i_k]);
        mcwgh.fWeight.insert(p);
      }

      //// fill the producer
      //evwgh::MCEventWeight mcwgh;
      //if(weights[i_v].size() == 0){ // dummy check for no dials
      //  std::vector<double> empty;
      //  std::pair<std::string, std::vector <double> > p("empty",empty);
      //  mcwgh.fWeight.insert(p);
      //}
      //else{
      //  for (unsigned int i_k = 0; i_k < num_knobs; i_k++ ){
      //    std::pair<std::string, std::vector<double> > p(knob_name[i_k], weights[i_v][i_k]);
      //    mcwgh.fWeight.insert(p);
      //  } // knobs
      //  for (unsigned int i_k = 0; i_k < tuned_num_knobs; i_k++ ){
      //    std::pair<std::string, std::vector<double> > p(tuned_knob_name[i_k], weights[i_v][i_k]);
      //    mcwgh.fWeight.insert(p);
      //  } // tuned knobs
      //} 
      mcwghvec->push_back(mcwgh);
    } // neutrino

    e.put(std::move(mcwghvec));
  }

  void EventWeightSysYC::beginJob()
  {
  }

  void EventWeightSysYC::endJob()
  {
  }

} // namespace

DEFINE_ART_MODULE(evwghYC::EventWeightSysYC)
