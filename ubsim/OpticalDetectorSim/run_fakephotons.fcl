#include "services_microboone.fcl"
#include "triggersim_microboone.fcl"
#include "opticaldetectorsim_microboone.fcl"
#include "time_memory_tracker_microboone.fcl"
#include "opticaldetectormodules_microboone.fcl"
#include "correct_saturation.fcl"
#include "ubflashfinder.fcl"
process_name: FakePhotons

services:
{
  scheduler:    { defaultExceptions: false }
  TFileService: { fileName: "trump.root" }
  RandomNumberGenerator: {}
  @table::microboone_detsim_services
}

source:
{
  module_type: EmptyEvent
  timestampPlugin: { plugin_type: "GeneratedEventTimestamp" }
  maxEvents:1 firstRun:1 firstEvent:1
}

physics:
{

 analyzers:
 {
   #
   # FakePhotonsAna analysis module stores some simple information about simulated waveforms.
   # This is meant for testing the optical detector response simulation and timing simulation.
   #
   fakeana0: { module_type: "FakePhotonsAna"
               ModuleLabel: "pmtreadout:OpdetCosmicHighGain" # Specify a type of readout waveform to analyze
               Threshold:   2058 # The minimum ADC value in an waveform to be stored in the output.
               StoreWaveform: 1 # If 1, store an waveform itself. Else only summary info (start time, peak time, channel number, max adc) are stored.
               AnaFile: "ana_cosmic.root" # Output root file name (make sure it's unique).
            }
   fakeana1: { module_type: "FakePhotonsAna"
               ModuleLabel: "pmtreadout:OpdetBeamHighGain" # Specify a type of readout waveform to analyze
               Threshold:   2058 # The minimum ADC value in an waveform to be stored in the output.
               StoreWaveform: 1 # If 1, store an waveform itself. Else only summary info (start time, peak time, channel number, max adc) are stored.
               AnaFile: "ana_beam.root" # Output root file name (make sure it's unique).
            }
 }

 producers:
 {
   # We configure modules to generate photons & run optical simulation chain (including hardware trigger)
   # Note 2 new modules introduced in addition to other "usual modules": electime and fakephotons.
   # They will be commented massively below.
   electime:   {  module_type: "ElectronicsClockSim"
                  # This module is a "generator" that insert a data product called ElectronicsClockInfo.
                  # ElectronicsClockInfo carries only 1 information: the electronics clock start time in G4 time frame.
                  G4RefTime:   -3.2e3 # Electronics clock start time (T0) in G4 time frame BUT in MICRO-SECONDS [us]!
                  RandomShift: 1600   # The Electronics clock T0 is varied between 0 to the RandomShift value (in [us]).
                  MakeRunData: 1 # 1 if you starting with EmptyEvent (this fcl is, yes).
               }
   fakephotons:{  module_type: "FakePhotons"
                  # This module is a "generator" that can shoot fake photons into PMTs.
                  # It is designed to study the optical detector response simulation chain.
                  MakeRunData: 0  # 1 if you starting with EmptyEvent (no because we run electime)
                  PELevel: 200 # Number of photons to inject into a PMT for a single "pulse".
                  #
                  # Per-PMT configuration...
                  #
                  # Configure individual OpDet (PMT) for an array of pulse timing in G4 ns.
                  # You can specify by PMTX parameter where X goes from 0 to 31 (or geo->NOpDets() return value to be exact).
                  # If not specified, no photon is fired.
                  # Each entry in an array means a firing of N photons (where N is set by PELevel parameter) at the specified G4 time [ns]
                  PMT0: [0.]
                  PMT1: [1.]
                  PMT2: [2.]
                  PMT3: [3.]
                  PMT4: [4.]
                  PMT5: [5.]
                  PMT6: [6.]
                  PMT7: [7.]
                  PMT8: [8.]
                  PMT9: [9.]
                  PMT10: [10.]
                  PMT11: [11.]
                  PMT12: [12.]
                  PMT13: [13.]
                  PMT14: [14.]
                  PMT15: [15.]
                  PMT25: [0.]
                  #
                  # Periodic pulse configuration
                  #
                  Start: -3200000 # start time of pulsing in G4 ns
                  End:   -4800000 # end time of pulsing in G4 ns
                  Period:   10000 # period between pulsing (e.g. 1000 means 1us = 1MHz pulse)
                  OpDetList: [0]  # list of OpDet to fire this periodic pulses
               }
   optdigitizer:   @local::microboone_optical_adc_sim
   optfem:         @local::microboone_optical_fem_sim
   triggersim:     @local::ubtrigger_dark_bnb
   pmtreadout:     @local::microboone_optical_dram_readout_sim
   ophitBeam         : @local::microboone_ophit_saturation_beam
   ophitCosmic       : @local::microboone_ophit_saturation_cosmic
   saturation        : @local::correct_saturation_mc
   simpleFlashBeam   : @local::UBFlashBeamMC
   simpleFlashCosmic : @local::UBFlashCosmicMC
  
   rns: { module_type: "RandomNumberSaver" }
 }

 # Run this chain if you want to include reconstruction
 #simulate: [ rns, fakephotons, optdigitizer, optfem, triggersim, pmtreadout, saturation, ophitBeam, ophitCosmic, simpleFlashBeam, simpleFlashCosmic ]

 # Or run this chain if you need just up to the end of optical/trigger simulation
 simulate: [ rns, electime, fakephotons, optdigitizer, optfem, triggersim, pmtreadout ]

 analyze:  [ fakeana0, fakeana1 ]
 outstrm:  [out]
 trigger_paths: [simulate] 
 end_paths:     [outstrm,analyze]
}
outputs:
{
 out:
 {
   module_type: RootOutput
   fileName:    "larsoft.root"
   dataTier:    "simulated"
   saveMemoryObjectThreshold: 0
   compressionLevel: 1
   fastCloning: false
 }
}


physics.producers.optdigitizer.G4ModName: "fakephotons"
